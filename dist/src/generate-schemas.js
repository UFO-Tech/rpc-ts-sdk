// src/generate-schemas.ts
import * as fs from 'fs';
function toTSType(schema, schemas, level = 0) {
    if (!schema)
        return 'any';
    if (schema.enum) {
        return schema.enum.map((v) => typeof v === 'string' ? `"${v}"` : v).join(' | ');
    }
    if (schema.oneOf) {
        const types = schema.oneOf.map((option) => toTSType(option, schemas, level + 1));
        return Array.from(new Set(types)).join(' | ');
    }
    if (schema.allOf) {
        return schema.allOf.map((option) => toTSType(option, schemas, level + 1)).join(' & ');
    }
    if (schema.type === 'array') {
        let itemType = schema.items
            ? toTSType(schema.items, schemas, level + 1)
            : (schema.default ? toTSType({ type: typeof schema.default }, schemas, level + 1) : 'any');
        return `${itemType}[]`;
    }
    if (Array.isArray(schema.type)) {
        // type: ['string', 'null'] etc
        return schema.type.map((t) => toTSType({ type: t }, schemas, level + 1)).join(' | ');
    }
    if (schema.type === 'object' || schema.properties) {
        if (schema.$ref) {
            return schema.$ref.split('/').pop();
        }
        if (schema.properties) {
            const fields = Object.entries(schema.properties)
                .map(([k, v]) => {
                const required = (schema.required || []).includes(k);
                return `${k}${required ? '' : '?'}: ${toTSType(v, schemas, level + 1)};`;
            }).join(' ');
            return `{ ${fields} }`;
        }
        return 'Record<string, any>';
    }
    if (schema.$ref) {
        return schema.$ref.split('/').pop();
    }
    switch (schema.type) {
        case 'string': return 'string';
        case 'integer':
        case 'number': return 'number';
        case 'boolean': return 'boolean';
        case 'null': return 'null';
        default: return 'any';
    }
}
function generateInterfaces(schemas) {
    let output = `// Generated by ufo-tech/rpc-ts-sdk\n\n`;
    for (const [schemaName, schemaDef] of Object.entries(schemas)) {
        output += `export interface ${schemaName} {\n`;
        const props = schemaDef.properties || {};
        const required = schemaDef.required || [];
        for (const [propName, propSchema] of Object.entries(props)) {
            if (propSchema.description) {
                output += `  /** ${propSchema.description} */\n`;
            }
            const isRequired = required.includes(propName);
            output += `  ${propName}${isRequired ? '' : '?'}: ${toTSType(propSchema, schemas)};\n`;
        }
        output += `}\n\n`;
    }
    // Додаємо інтерфейс обробки помилок:
    output += `export interface RpcError {\n  code: number;\n  message: string;\n  data?: any;\n}\n\n`;
    return output;
}
export async function generateSchemas({ input, output }) {
    let openrpc;
    if (/^https?:\/\//.test(input)) {
        // fetch з url (Node 18+)
        const res = await fetch(input);
        if (!res.ok)
            throw new Error(`Failed to fetch open-rpc docs: ${res.statusText}`);
        openrpc = await res.json();
    }
    else {
        openrpc = JSON.parse(fs.readFileSync(input, 'utf-8'));
    }
    const schemas = openrpc.components && openrpc.components.schemas;
    if (!schemas) {
        console.error('No components.schemas found!');
        process.exit(1);
    }
    const tsInterfaces = generateInterfaces(schemas);
    fs.writeFileSync(output, tsInterfaces);
    console.log(`✓ TypeScript interfaces generated to ${output}`);
}
