// src/generate-schemas.ts
import * as fs from 'fs';

type JSONSchema = any;

function toTSType(schema: JSONSchema, schemas: any, level = 0): string {
    if (!schema) return 'any';

    if (schema.enum) {
        return schema.enum.map((v: any) => typeof v === 'string' ? `"${v}"` : v).join(' | ');
    }
    if (schema.oneOf) {
        const types = schema.oneOf.map((option: any) => toTSType(option, schemas, level + 1));
        return Array.from(new Set(types)).join(' | ');
    }
    if (schema.allOf) {
        return schema.allOf.map((option: any) => toTSType(option, schemas, level + 1)).join(' & ');
    }
    if (schema.type === 'array') {
        let itemType = schema.items
            ? toTSType(schema.items, schemas, level + 1)
            : (schema.default ? toTSType({ type: typeof schema.default }, schemas, level + 1) : 'any');
        return `${itemType}[]`;
    }
    if (Array.isArray(schema.type)) {
        // type: ['string', 'null'] etc
        return schema.type.map((t: string) => toTSType({ type: t }, schemas, level + 1)).join(' | ');
    }

    if (schema.type === 'object' || schema.properties) {
        if (schema.$ref) {
            return schema.$ref.split('/').pop();
        }
        if (schema.properties) {
            const fields = Object.entries(schema.properties)
                .map(([k, v]) => {
                    const required = (schema.required || []).includes(k);
                    return `${k}${required ? '' : '?'}: ${toTSType(v, schemas, level + 1)};`;
                }).join(' ');
            return `{ ${fields} }`;
        }
        return 'Record<string, any>';
    }
    if (schema.$ref) {
        return schema.$ref.split('/').pop();
    }
    switch (schema.type) {
        case 'string': return 'string';
        case 'integer':
        case 'number': return 'number';
        case 'boolean': return 'boolean';
        case 'null': return 'null';
        default: return 'any';
    }
}

function generateInterfaces(schemas: any): string {
    let output = `// Generated by ufo-tech/rpc-ts-sdk\n\n`;
    for (const [schemaName, schemaDef] of Object.entries(schemas as Record<string, any>)) {
        output += `export interface ${schemaName} {\n`;
        const props = (schemaDef as any).properties || {};
        const required = (schemaDef as any).required || [];
        for (const [propName, propSchema] of Object.entries(props as Record<string, any>)) {
            if ((propSchema as any).description) {
                output += `  /** ${(propSchema as any).description} */\n`;
            }
            const isRequired = required.includes(propName);
            output += `  ${propName}${isRequired ? '' : '?'}: ${toTSType(propSchema, schemas)};\n`;
        }
        output += `}\n\n`;
    }
    // Додаємо інтерфейс обробки помилок:
    output += `export interface RpcError {\n  code: number;\n  message: string;\n  data?: any;\n}\n\n`;
    return output;
}

export async function generateSchemas({
                                          input,
                                          output
                                      }: { input: string, output: string }) {
    let openrpc: any;

    if (/^https?:\/\//.test(input)) {
        // fetch з url (Node 18+)
        const res = await fetch(input);
        if (!res.ok) throw new Error(`Failed to fetch open-rpc docs: ${res.statusText}`);
        openrpc = await res.json();
    } else {
        openrpc = JSON.parse(fs.readFileSync(input, 'utf-8'));
    }
    const schemas = openrpc.components && openrpc.components.schemas;
    if (!schemas) {
        console.error('No components.schemas found!');
        process.exit(1);
    }
    const tsInterfaces = generateInterfaces(schemas);
    fs.writeFileSync(output, tsInterfaces);
    console.log(`✓ TypeScript interfaces generated to ${output}`);
}